<body style="color: #6e5494; background-color:#fafafa; font-family: calibri;">
  <head>
Chapter 5: Programming Algorithms & Software Testing
  </head>
  <body style="color:#e4e3e3;background-color:#e97101;font-family:tahoma,verdana;">
<h3>Phases of computer program development:</h3>
      <li>Phase 1: Understand the problem</li>
      <li>Phase 2: Design an algorithm to solve the problem</li>
      <li>Phase 3: Write the program code in appropriate language based on the algorithm</li>
      <li>Phase 4: Enter the program and save</li>
      <li>Phase 5: Execute the program</li>
      <li>Phase 6: Test the program, find errors and debug, then retest</li>
      <li>Phase s7: Document and evaluate the program</li>
<h3>Programming structures:</h3>
    <h3>Sequential structure: Top-down execution</h3>
    <h3>Decision structures: if/then/else</h3>
    <h3>Iterative (Looping):</h3>
        <li>while 1loop: continue 1oop√≠ng as long something is true</li>
        <li>repeat/until 1oop: continue 1oopi ng until something is true</li>
        <li>for loop: loop a given number of times</li>
    <h3>Recursive structures:</h3>
        <h3>Repeat a set of instructions as a subtask of itself</h3>
        <h3>Repetition continues until:</h3>
            <li>degenerative case, which is a termination condition, is met</li>
            <li>(degener ative case is also call ed a "base case")</li>
<h3>Two classic progr ammng/databas e problems</h3>
    <h3>Sorting: Descending order /As cending order</h3>
        <li>Sorting numbers</li>
        <li>Sorting strings (in accordance with ASCII values)</li>
    <h3>Searching: find specific data that meet a certain criteria</h3>
        <h3>In database:</h3>
              <li>FilterS: temporary search</li>
              <li>Queries: search criteria are saved so they don't have to be recreated</li>
        <h3>Two popular search techniques:</h3>
              <h3>Sequential search: search from top to bottom or bottom to top, one item at a time
              Binary search:</h3>
                  <li>only works if data is SORTED first</li>
                  <li>start in the middle, then go to half of that, etc.</li>
<h3>Two classic program goals:</h3>
      <li>Efficiency: Progr am takes minimal time and/or resources</li>
      <li>Correctness: Progr am runs in expected ways and works for all expected conditions</li>
   
<h2>Software testing and verification</h2>
      <h3>Kinds of tests:</h3>
<h3>(Find the definitions for these here: https://www. ibm. com/topi cs/software-testing)</h3>
            <li>Acceptance testing: Acceptance testing is a quality assurance (QA) process that determines to what degree an application meets end users' approval. </li>
            <li>Integration testing: Integration testing is the phase in software testing in which individual software modules are combined and tested as a group.</li>
            <li>Unit testing: Unit testing is a software development process in which the smallest testable parts of an application, called units, are individually and independently scrutinized for proper operation.</li>
            <li>Functionall testing: Is a type of software testing that validates the software system against the functional requirements/specifications.</li>
            <li>Performance testing: performance testing is in general a testing practice performed to determine how a system performs in terms of responsiveness and stability under a particular workload.</li>
            <li>Regression testing: Regression testing is re-running functional and non-functional tests to ensure that previously developed and tested software still performs as expected after a change.</li>
            <li>Stress testing: Stress testing is a form of deliberately intense or thorough testing, used to determine the stability of a given system, critical infrastructure or entity.</li>
            <li>Usability testing: Usability testing is a technique used in user-centered interaction design to evaluate a product by testing it on users.</li>
      <h3>Software testing is done to detect:</h3>
            <li>Architectural flaws: Architectural flaws are results of inappropriate design choices in early stages of software development, incorrect implementation of security patterns, or degradation of security architecture over time.</li>
            <li>Poor design decisions: A design decision uses data to prioritize user needs over design bias.</li>
            <li>Invalid or incorrect functionality: The Error is a human mistake. An Error appears not only due to the logical mistake in the code made by the developer.</li>
            <li>Security vulner abilities: A flaw or weakness in a computer system, its security procedures, internal controls, or design and implementation, which could be exploited to violate the system security policy.</li>
            <li>Scalability issues: Scalability is the measure of a system's ability to increase or decrease in performance and cost in response to changes in application and system processing demands.</li>
      <h3>Testing best practices:</h3>
<h3>(explain these--see the IBM web site for the information)</h3>
            <li>Continous testing: Continuous testing is the process of executing automated tests as part of the software delivery pipeline to obtain immediate feedback on the business risks associated with a software release candidate.</li>
            <li>Configuration management: Configuration management is a process for establishing and maintaining consistency of a product's performance, functional, and physical attributes with its requirements, design, and operational information throughout its life.</li>
            <li>Service Virtualization: service virtualisation is a method to emulate the behavior of specific components in heterogeneous component-based applications such as API-driven applications, cloud-based applications and service-oriented architectures</li>
            <li>Defect or "bug tracking: Bug tracking is the process of logging and monitoring bugs or errors during software testing.</li>
            <li>Metrics and reporting: Metrics reporting is a method that companies use to understand their KPIs, which can help them discover if they're going to meet their goals within a specific period.</li>
  From: IBM What is software testing? (make this a link to: https://www.i bm. com/topics/software-testing
